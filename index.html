<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>E.L.I.A.N. Asistente de Voz</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: 'Orbitron', sans-serif;
      background: #000000;
      color: #00ffff;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      text-align: center;
    }

    #header-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 2em;
    }
    
    #logo-svg {
      width: 220px; /* Un poco m√°s grande para m√°s impacto */
      height: 220px;
      margin-bottom: 1em;
      filter: drop-shadow(0 0 15px #00ffff);
      animation: logo-pulse 3s infinite alternate;
    }
    
    .tech-element {
      fill: none;
      stroke: #00ffff;
      stroke-width: 1.5px;
      transform-origin: center;
      filter: drop-shadow(0 0 3px #00ffff); /* Sutil brillo para cada elemento */
    }

    .tech-core {
      fill: #00ffff;
      stroke: #00ffff;
      stroke-width: 1px;
      filter: drop-shadow(0 0 8px #00ffff) drop-shadow(0 0 15px #00ffff);
      animation: core-glow 1.5s infinite alternate;
    }

    /* Animaciones para las diferentes capas */
    .outer-ring {
      animation: rotate-slow 20s linear infinite;
    }
    .inner-ring {
      animation: rotate-fast 10s linear infinite reverse;
    }
    .grid-lines {
      stroke-dasharray: 40 20; /* Patr√≥n de puntos/guiones */
      stroke-dashoffset: 0;
      animation: dash-flow 5s linear infinite;
    }
    .energy-arcs {
      stroke-dasharray: 0, 100;
      stroke-dashoffset: 0;
      animation: arc-flow 3s ease-in-out infinite alternate;
    }

    @keyframes logo-pulse {
      0% { transform: scale(1); filter: drop-shadow(0 0 10px #00ffff); }
      100% { transform: scale(1.05); filter: drop-shadow(0 0 25px #00ffff); }
    }

    @keyframes core-glow {
      0% { transform: scale(1); opacity: 0.8; }
      100% { transform: scale(1.2); opacity: 1; }
    }
    
    @keyframes rotate-slow {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    @keyframes rotate-fast {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    @keyframes dash-flow {
      from { stroke-dashoffset: 0; }
      to { stroke-dashoffset: 60; } /* Ajustado para el patr√≥n dasharray */
    }

    @keyframes arc-flow {
      0% { stroke-dasharray: 0, 100; stroke-dashoffset: 0; }
      50% { stroke-dasharray: 100, 0; stroke-dashoffset: 0; }
      100% { stroke-dasharray: 0, 100; stroke-dashoffset: -100; }
    }

    h1 {
      font-size: 3.5em;
      margin-bottom: 0.5em;
      color: #00ffff;
      text-shadow: 0 0 25px #00ffff, 0 0 50px #00ffff;
    }

    #estado, #error {
      font-size: 1.3em;
      margin-top: 1em;
      color: #ffffff;
      text-shadow: 0 0 8px #00ffff;
    }
    
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: -1;
      filter: blur(0.7px);
      opacity: 0.7;
    }
    
  </style>
</head>
<body>
  <div id="header-container">
    <svg id="logo-svg" viewBox="0 0 200 200">
      <circle class="tech-element outer-ring grid-lines" cx="100" cy="100" r="90" />
      
      <path class="tech-element inner-ring energy-arcs" 
            d="M 100 10 C 140 10, 190 60, 190 100 C 190 140, 140 190, 100 190 C 60 190, 10 140, 10 100 C 10 60, 60 10, 100 10" 
            stroke-width="2.5px"/>

      <polygon class="tech-element" 
               points="100,60 130,80 130,120 100,140 70,120 70,80" 
               transform-origin="center" 
               style="animation: rotate-slow 18s linear infinite reverse;"/>

      <circle class="tech-core" cx="100" cy="100" r="15" />
    </svg>
    <h1>E.L.I.A.N.</h1>
  </div>
  
  <div id="estado">‚è≥ Iniciando...</div>
  <div id="error"></div>
  <canvas id="fondo"></canvas>

  <script>
    const estadoDiv = document.getElementById("estado");
    const errorDiv = document.getElementById("error");
    let reconocimiento;
    let isSpeaking = false;
    let isMicPermissionGranted = false; // Bandera para rastrear el permiso del micr√≥fono

    // --- Funciones de Voz y Reconocimiento ---

    function hablar(texto) {
      isSpeaking = true;
      const voz = new SpeechSynthesisUtterance(texto);
      voz.lang = "es-ES";
      voz.pitch = 0.9;
      voz.rate = 0.85; // Reducido ligeramente para un tono menos rob√≥tico

      const seleccionarVoz = () => {
        const voces = window.speechSynthesis.getVoices();
        // Intentar encontrar una voz premium o una voz de Google Espa√±ol m√°s natural
        const vozElegida = voces.find(v => v.name.toLowerCase().includes("google espa√±ol") && v.name.toLowerCase().includes("premium")) ||
                               voces.find(v => v.name.toLowerCase().includes("google espa√±ol")) ||
                               voces.find(v => v.name.toLowerCase().includes("pablo")) || // Mantiene la opci√≥n de Pablo si est√° disponible
                               voces.find(v => v.lang === 'es-ES' && v.name.toLowerCase().includes("male")) || // Voz masculina en espa√±ol
                               voces.find(v => v.lang === 'es-ES'); // Cualquier otra voz en espa√±ol
        if (vozElegida) {
          voz.voice = vozElegida;
          console.log("Voz seleccionada:", vozElegida.name);
        } else {
          console.warn("No se encontr√≥ una voz espec√≠fica en espa√±ol. Usando voz predeterminada.");
        }
      };

      if (speechSynthesis.getVoices().length === 0) {
        window.speechSynthesis.onvoiceschanged = seleccionarVoz;
      } else {
        seleccionarVoz();
      }

      speechSynthesis.speak(voz);
      voz.onend = () => {
        isSpeaking = false;
        // Reinicia el reconocimiento SOLO si el micr√≥fono est√° habilitado y el asistente no est√° apagado
        if (isMicPermissionGranted && estadoDiv.textContent !== "üí§ E.L.I.A.N. se ha apagado.") {
            // Esperar un peque√±o margen para que la voz termine completamente antes de reiniciar
            setTimeout(() => {
                reconocimiento.start();
            }, 500); 
        }
      };
    }

    // --- Solicitud de Permisos y Manejo de Inicializaci√≥n ---

    async function solicitarPermisos() {
      estadoDiv.textContent = "üõ°Ô∏è Solicitando permisos...";
      errorDiv.textContent = "";

      const micPermission = await navigator.permissions.query({ name: 'microphone' });
      if (micPermission.state === 'granted' || micPermission.state === 'prompt') {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          console.log("üé§ Micr√≥fono activado correctamente.");
          isMicPermissionGranted = true;
          estadoDiv.textContent = "‚úÖ Permisos de micr√≥fono concedidos.";
          // Una vez que el micr√≥fono est√° listo, podemos iniciar el reconocimiento
          iniciarReconocimiento();
        } catch (err) {
          console.error("‚ùå Error al activar el micr√≥fono:", err);
          errorDiv.textContent = `‚ö†Ô∏è No se pudo acceder al micr√≥fono: ${err.message}. Por favor, habilite el acceso en la configuraci√≥n de su dispositivo.`;
          estadoDiv.textContent = "‚ùå Error de micr√≥fono.";
          hablar("No he podido acceder a tu micr√≥fono. Por favor, aseg√∫rate de que el permiso est√© habilitado en la configuraci√≥n de tu navegador o dispositivo.");
        }
      } else {
        // Permiso denegado permanentemente o bloqueado
        console.error("‚ùå Permiso de micr√≥fono denegado o bloqueado.");
        errorDiv.textContent = "‚ùå Permiso de micr√≥fono denegado o bloqueado. Revise la configuraci√≥n de su navegador/dispositivo.";
        estadoDiv.textContent = "‚ùå Permiso de micr√≥fono denegado.";
        hablar("El acceso al micr√≥fono ha sido bloqueado permanentemente. No podr√© escucharte.");
      }

      // NOTA SOBRE UBICACI√ìN Y LLAMADAS:
      // En aplicaciones web est√°ndar, el acceso directo a Ubicaci√≥n y Llamadas es limitado.
      // Se pueden *enlazar* a ellas, pero no *acceder* program√°ticamente sin intervenci√≥n del usuario.
      // Para un acceso real, necesitar√≠as una App Nativa o un wrapper (como Cordova/Capacitor) con permisos espec√≠ficos.

      // Ejemplo de c√≥mo enlazar a la ubicaci√≥n (abre la aplicaci√≥n de mapas del usuario)
      // Este c√≥digo se ejecutar√≠a dentro de una funci√≥n de comando, por ejemplo:
      /*
      if (textoNormalizado.includes("mostrar mi ubicacion")) {
          window.open("geo:0,0?q=Mi Ubicacion"); // O usa window.navigator.geolocation si el permiso se concede
          hablar("Abriendo mapa para mostrar tu ubicaci√≥n.");
      }
      */
      
      // Ejemplo de c√≥mo enlazar a hacer una llamada (abre la aplicaci√≥n de tel√©fono)
      // Este c√≥digo se ejecutar√≠a dentro de una funci√≥n de comando, por ejemplo:
      /*
      if (textoNormalizado.includes("llamar a")) {
          const numero = textoNormalizado.replace("llamar a", "").trim(); // Simplificado, necesitar√≠a parseo de n√∫mero
          window.location.href = `tel:${numero}`; // Abre la app de tel√©fono
          hablar(`Iniciando llamada al n√∫mero ${numero}.`);
      }
      */
    }

    // --- Procesamiento de Comandos ---

    async function procesarComando(texto) {
      const textoNormalizado = texto.toLowerCase().trim();

      if (textoNormalizado.includes("elian apagar")) {
        hablar("Ha sido un placer servirle. E.L.I.A.N. se apaga.");
        estadoDiv.textContent = "üí§ E.L.I.A.N. se ha apagado.";
        if (reconocimiento) {
            reconocimiento.stop();
        }
        return;
      }

      // Solo procesar comandos si el micr√≥fono est√° activo y no estamos hablando
      if (!isMicPermissionGranted || isSpeaking) {
          console.log("Esperando permiso de microfono o fin de habla...");
          return;
      }

      estadoDiv.textContent = "üß† E.L.I.A.N. est√° pensando...";

      try {
        const apiKey = "AIzaSyAS_N-kiSDdKqCiHrDE1q68H83vFgkeyJY"; // ¬°Revisa la validez de esta API Key!
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
        
        const payload = {
          contents: [{ parts: [{ text: textoNormalizado }] }],
          tools: [{ "google_search": {} }],
          systemInstruction: {
            parts: [{ text: "Act√∫a como un asistente de voz llamado E.L.I.A.N.. S√© conciso, √∫til y responde en espa√±ol. Utiliza un tono profesional y educado, como un asistente personal avanzado. Responde a cualquier pregunta que te hagan sobre cualquier tema. Si te preguntan sobre el tiempo o la fecha, proporciona la informaci√≥n actual. No menciones tu programaci√≥n ni que eres un modelo de lenguaje." }]
          },
        };

        const response = await fetch(apiUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });

        if (!response.ok) {
          throw new Error(`Error en la API: ${response.statusText} (${response.status})`);
        }

        const result = await response.json();
        const generatedText = result?.candidates?.[0]?.content?.parts?.[0]?.text;
        
        if (generatedText) {
          estadoDiv.textContent = `üó£Ô∏è He escuchado: "${texto}"`;
          hablar(generatedText);
        } else {
          estadoDiv.textContent = `‚ö†Ô∏è No se pudo obtener una respuesta.`;
          hablar("Lo siento, no pude procesar su solicitud en este momento. Int√©ntelo de nuevo m√°s tarde.");
        }
      } catch (error) {
        console.error("Error al llamar a la API:", error);
        errorDiv.textContent = `‚ö†Ô∏è Error de conexi√≥n: ${error.message}`;
        hablar("Ha ocurrido un error al intentar conectarme. Por favor, revise su conexi√≥n a internet.");
      }
    }

    // --- Configuraci√≥n de SpeechRecognition ---

    function setupSpeechRecognition() {
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

      if (!SpeechRecognition) {
        estadoDiv.textContent = "‚ùå Su navegador no soporta el reconocimiento de voz.";
        errorDiv.textContent = "Utilice Google Chrome o Microsoft Edge.";
        hablar("Me temo que su navegador no es compatible. Le recomiendo utilizar Google Chrome o Microsoft Edge.");
        return false; // Indica que no se pudo configurar
      }

      reconocimiento = new SpeechRecognition();
      reconocimiento.lang = "es-ES";
      reconocimiento.interimResults = false; // Solo obtener resultados finales
      reconocimiento.continuous = false; // Detenerse despu√©s de una pausa en el habla

      reconocimiento.onstart = () => {
        console.log("SpeechRecognition: Iniciado.");
        // Solo actualizar si el micr√≥fono est√° realmente concedido y no estamos apagando
        if (isMicPermissionGranted && estadoDiv.textContent !== "üí§ E.L.I.A.N. se ha apagado.") {
          estadoDiv.textContent = "üéôÔ∏è E.L.I.A.N. est√° a la espera de sus √≥rdenes...";
        }
        errorDiv.textContent = "";
      };

      reconocimiento.onresult = (event) => {
        const texto = event.results[0][0].transcript;
        console.log("Voz detectada:", texto);
        procesarComando(texto);
      };

      reconocimiento.onerror = (event) => {
        console.error("SpeechRecognition Error:", event.error);
        // Errores comunes: "no-speech" (no detect√≥ habla), "audio-capture" (problema con el micro)
        if (event.error === "no-speech") {
            errorDiv.textContent = "‚ö†Ô∏è No se detect√≥ habla. Reiniciando...";
        } else if (event.error === "audio-capture") {
            errorDiv.textContent = "‚ö†Ô∏è Problema con el micr√≥fono. Reiniciando...";
            isMicPermissionGranted = false; // Considerar que el micro podr√≠a estar bloqueado
            // Intentar solicitar permisos de nuevo si hay un problema de captura
            setTimeout(solicitarPermisos, 2000); 
        }
        else {
            errorDiv.textContent = `‚ö†Ô∏è Error: ${event.error}. Reiniciando en 2 segundos...`;
        }
        // Reiniciar reconocimiento despu√©s de un error, SOLO si el asistente est√° activo
        setTimeout(() => {
          if (estadoDiv.textContent !== "üí§ E.L.I.A.N. se ha apagado.") {
              if(isMicPermissionGranted) reconocimiento.start(); // Reiniciar si el micro est√° listo
              else solicitarPermisos(); // Intentar solicitar permisos si el micro no est√°granted
          }
        }, 2000);
      };

      reconocimiento.onend = () => {
        console.log("SpeechRecognition: Finalizado.");
        // Si no estamos hablando y el asistente est√° activo, intentamos reiniciar el reconocimiento.
        if (!isSpeaking && estadoDiv.textContent !== "üí§ E.L.I.A.N. se ha apagado." && isMicPermissionGranted) {
          console.log("Reiniciando SpeechRecognition...");
          reconocimiento.start();
        }
      };
      return true; // Indica que se configur√≥ correctamente
    }

    // --- Inicializaci√≥n de Part√≠culas y Carga Principal ---

    function iniciarParticulas() {
      const canvas = document.getElementById("fondo");
      const ctx = canvas.getContext("2d");
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      const particulas = Array.from({ length: 300 }, () => ({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        r: Math.random() * 1.5 + 1,
        dx: (Math.random() - 0.5) * 0.7,
        dy: (Math.random() - 0.5) * 0.7
      }));

      function animar() {
        requestAnimationFrame(animar);
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        particulas.forEach(p => {
          p.x += p.dx;
          p.y += p.dy;

          if (p.x < 0 || p.x > canvas.width) p.dx *= -1;
          if (p.y < 0 || p.y > canvas.height) p.dy *= -1;

          ctx.beginPath();
          ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
          ctx.fillStyle = '#00ffff';
          ctx.fill();

          particulas.forEach(p2 => {
            const dist = Math.sqrt(Math.pow(p.x - p2.x, 2) + Math.pow(p.y - p2.y, 2));
            if (dist < 100) {
              ctx.beginPath();
              ctx.strokeStyle = `rgba(0, 255, 255, ${1 - dist / 100})`;
              ctx.lineWidth = 0.5;
              ctx.moveTo(p.x, p.y);
              ctx.lineTo(p2.x, p2.y);
              ctx.stroke();
            }
          });
        });
      }

      window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      });

      animar();
    }

    // --- Punto de Entrada Principal ---

    window.onload = () => {
      iniciarParticulas(); // Las part√≠culas se inician primero para que el fondo est√© listo
      
      // Configurar el reconocimiento de voz, pero no iniciarlo hasta tener permiso de micr√≥fono
      const recognitionConfigured = setupSpeechRecognition();
      
      if (recognitionConfigured) {
        solicitarPermisos(); // Solicitar permisos de micr√≥fono al cargar la p√°gina
      } else {
        // Si el navegador no soporta SpeechRecognition, mostrar el error
        estadoDiv.textContent = "‚ùå Su navegador no soporta el reconocimiento de voz.";
        errorDiv.textContent = "Utilice Google Chrome o Microsoft Edge.";
        hablar("Me temo que su navegador no es compatible. Le recomiendo utilizar Google Chrome o Microsoft Edge.");
      }
    };
  </script>
</body>
</html>