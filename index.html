<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>E.L.I.A.N. Asistente de Voz</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: 'Orbitron', sans-serif;
      background: #000000;
      color: #00ffff;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      text-align: center;
    }

    #header-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 2em;
    }
    
    #logo-svg {
      width: 220px;
      height: 220px;
      margin-bottom: 1em;
      filter: drop-shadow(0 0 15px #00ffff);
      animation: logo-pulse 3s infinite alternate;
    }
    
    .tech-element {
      fill: none;
      stroke: #00ffff;
      stroke-width: 1.5px;
      transform-origin: center;
      filter: drop-shadow(0 0 3px #00ffff);
    }

    .tech-core {
      fill: #00ffff;
      stroke: #00ffff;
      stroke-width: 1px;
      filter: drop-shadow(0 0 8px #00ffff) drop-shadow(0 0 15px #00ffff);
      animation: core-glow 1.5s infinite alternate;
    }

    .outer-ring {
      animation: rotate-slow 20s linear infinite;
    }
    .inner-ring {
      animation: rotate-fast 10s linear infinite reverse;
    }
    .grid-lines {
      stroke-dasharray: 40 20;
      stroke-dashoffset: 0;
      animation: dash-flow 5s linear infinite;
    }
    .energy-arcs {
      stroke-dasharray: 0, 100;
      stroke-dashoffset: 0;
      animation: arc-flow 3s ease-in-out infinite alternate;
    }

    @keyframes logo-pulse {
      0% { transform: scale(1); filter: drop-shadow(0 0 10px #00ffff); }
      100% { transform: scale(1.05); filter: drop-shadow(0 0 25px #00ffff); }
    }

    @keyframes core-glow {
      0% { transform: scale(1); opacity: 0.8; }
      100% { transform: scale(1.2); opacity: 1; }
    }
    
    @keyframes rotate-slow {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    @keyframes rotate-fast {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    @keyframes dash-flow {
      from { stroke-dashoffset: 0; }
      to { stroke-dashoffset: 60; }
    }

    @keyframes arc-flow {
      0% { stroke-dasharray: 0, 100; stroke-dashoffset: 0; }
      50% { stroke-dasharray: 100, 0; stroke-dashoffset: 0; }
      100% { stroke-dasharray: 0, 100; stroke-dashoffset: -100; }
    }

    h1 {
      font-size: 3.5em;
      margin-bottom: 0.5em;
      color: #00ffff;
      text-shadow: 0 0 25px #00ffff, 0 0 50px #00ffff;
    }

    #estado, #error {
      font-size: 1.3em;
      margin-top: 1em;
      color: #ffffff;
      text-shadow: 0 0 8px #00ffff;
    }
    
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: -1;
      filter: blur(0.7px);
      opacity: 0.7;
    }
    
  </style>
</head>
<body>
  <div id="header-container">
    <svg id="logo-svg" viewBox="0 0 200 200">
      <circle class="tech-element outer-ring grid-lines" cx="100" cy="100" r="90" />
      <path class="tech-element inner-ring energy-arcs" 
            d="M 100 10 C 140 10, 190 60, 190 100 C 190 140, 140 190, 100 190 C 60 190, 10 140, 10 100 C 10 60, 60 10, 100 10" 
            stroke-width="2.5px"/>
      <polygon class="tech-element" 
               points="100,60 130,80 130,120 100,140 70,120 70,80" 
               transform-origin="center" 
               style="animation: rotate-slow 18s linear infinite reverse;"/>
      <circle class="tech-core" cx="100" cy="100" r="15" />
    </svg>
    <h1>E.L.I.A.N.</h1>
  </div>
  
  <div id="estado">‚è≥ Iniciando...</div>
  <div id="error"></div>
  <canvas id="fondo"></canvas>

  <script>
    const estadoDiv = document.getElementById("estado");
    const errorDiv = document.getElementById("error");
    let reconocimiento;
    let isSpeaking = false;
    let mediaStream = null; // Para mantener la referencia del stream de audio

    function hablar(texto) {
      isSpeaking = true;
      const voz = new SpeechSynthesisUtterance(texto);
      voz.lang = "es-ES";
      voz.pitch = 0.9;
      voz.rate = 0.85;

      const seleccionarVoz = () => {
        const voces = window.speechSynthesis.getVoices();
        const vozElegida = voces.find(v => v.name.toLowerCase().includes("google espa√±ol") && v.name.toLowerCase().includes("premium")) ||
                               voces.find(v => v.name.toLowerCase().includes("google espa√±ol")) ||
                               voces.find(v => v.name.toLowerCase().includes("pablo")) ||
                               voces.find(v => v.lang === 'es-ES' && v.name.toLowerCase().includes("male")) ||
                               voces.find(v => v.lang === 'es-ES');
        if (vozElegida) {
          voz.voice = vozElegida;
        }
      };

      if (speechSynthesis.getVoices().length === 0) {
        window.speechSynthesis.onvoiceschanged = seleccionarVoz;
      } else {
        seleccionarVoz();
      }

      speechSynthesis.speak(voz);
      voz.onend = () => {
        isSpeaking = false;
        // Reiniciar reconocimiento solo si no se ha apagado y no est√° hablando
        if (estadoDiv.textContent !== "üí§ E.L.I.A.N. se ha apagado." && !isSpeaking) {
            // Peque√±a pausa para asegurar que el evento onend de habla termine
            setTimeout(() => {
                if(reconocimiento) reconocimiento.start();
            }, 100);
        }
      };
    }

    async function procesarComando(texto) {
      const textoNormalizado = texto.toLowerCase().trim();

      if (textoNormalizado.includes("elian apagar")) {
        hablar("Ha sido un placer servirle. E.L.I.A.N. se apaga.");
        estadoDiv.textContent = "üí§ E.L.I.A.N. se ha apagado.";
        if (reconocimiento) {
            reconocimiento.stop();
        }
        // Opcional: detener el stream de audio si se mantiene activo
        if (mediaStream) {
            mediaStream.getTracks().forEach(track => track.stop());
            mediaStream = null;
        }
        return;
      }

      estadoDiv.textContent = "üß† E.L.I.A.N. est√° pensando...";

      try {
        const apiKey = "AIzaSyAS_N-kiSDdKqCiHrDE1q68H83vFgkeyJY";
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
        
        const payload = {
          contents: [{ parts: [{ text: textoNormalizado }] }],
          tools: [{ "google_search": {} }],
          systemInstruction: {
            parts: [{ text: "Act√∫a como un asistente de voz llamado E.L.I.A.N.. S√© conciso, √∫til y responde en espa√±ol. Utiliza un tono profesional y educado, como un asistente personal avanzado. Responde a cualquier pregunta que te hagan sobre cualquier tema. Si te preguntan sobre el tiempo o la fecha, proporciona la informaci√≥n actual. No menciones tu programaci√≥n ni que eres un modelo de lenguaje." }]
          },
        };

        const response = await fetch(apiUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });

        if (!response.ok) {
          throw new Error(`Error en la API: ${response.statusText}`);
        }

        const result = await response.json();
        const generatedText = result?.candidates?.[0]?.content?.parts?.[0]?.text;
        
        if (generatedText) {
          estadoDiv.textContent = `üó£Ô∏è He escuchado: "${texto}"`;
          hablar(generatedText);
        } else {
          estadoDiv.textContent = `‚ö†Ô∏è No se pudo obtener una respuesta.`;
          hablar("Lo siento, no pude procesar su solicitud en este momento. Int√©ntelo de nuevo m√°s tarde.");
        }
      } catch (error) {
        console.error("Error al llamar a la API:", error);
        errorDiv.textContent = `‚ö†Ô∏è Error de conexi√≥n: ${error.message}`;
        hablar("Ha ocurrido un error al intentar conectarme. Por favor, revise su conexi√≥n a internet.");
      }
    }

    function iniciarReconocimiento() {
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

      if (!SpeechRecognition) {
        estadoDiv.textContent = "‚ùå Su navegador no soporta el reconocimiento de voz.";
        errorDiv.textContent = "Utilice Google Chrome o Microsoft Edge.";
        hablar("Me temo que su navegador no es compatible. Le recomiendo utilizar Google Chrome o Microsoft Edge.");
        return;
      }

      reconocimiento = new SpeechRecognition();
      reconocimiento.lang = "es-ES";
      reconocimiento.interimResults = false;
      reconocimiento.continuous = false; // false para detener al final de la frase

      reconocimiento.onstart = () => {
        estadoDiv.textContent = "üéôÔ∏è E.L.I.A.N. est√° a la espera de sus √≥rdenes...";
        errorDiv.textContent = "";
      };

      reconocimiento.onresult = (event) => {
        const texto = event.results[0][0].transcript;
        procesarComando(texto);
      };

      reconocimiento.onerror = (event) => {
        console.error("Speech Recognition Error:", event.error);
        errorDiv.textContent = `‚ö†Ô∏è Error: ${event.error}. Reiniciando en 2 segundos...`;
        // Si el error es de permisos, no intentar reiniciar para evitar bucles
        if (event.error === 'no-speech' || event.error === 'aborted') {
            // Puede ser un error temporal o relacionado con el silencio
        } else if (event.error === 'not-allowed') {
            errorDiv.textContent = `‚ö†Ô∏è Error de permisos. Por favor, aseg√∫rese de haber otorgado acceso al micr√≥fono.`;
            hablar("No tengo permiso para acceder al micr√≥fono. Por favor, revise la configuraci√≥n de su dispositivo o navegador.");
            return; // Detener el reinicio si es un error de permisos
        }
        
        setTimeout(() => {
          if (estadoDiv.textContent !== "üí§ E.L.I.A.N. se ha apagado." && !isSpeaking) {
              reconocimiento.start();
          }
        }, 2000);
      };

      reconocimiento.onend = () => {
        // Solo reiniciar si no se ha apagado manualmente y no est√° hablando
        if (estadoDiv.textContent !== "üí§ E.L.I.A.N. se ha apagado." && !isSpeaking) {
          reconocimiento.start();
        }
      };

      // Iniciar el reconocimiento
      reconocimiento.start();
    }

    function iniciarParticulas() {
      const canvas = document.getElementById("fondo");
      const ctx = canvas.getContext("2d");
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      const particulas = Array.from({ length: 300 }, () => ({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        r: Math.random() * 1.5 + 1,
        dx: (Math.random() - 0.5) * 0.7,
        dy: (Math.random() - 0.5) * 0.7
      }));

      function animar() {
        requestAnimationFrame(animar);
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        particulas.forEach(p => {
          p.x += p.dx;
          p.y += p.dy;

          if (p.x < 0 || p.x > canvas.width) p.dx *= -1;
          if (p.y < 0 || p.y > canvas.height) p.dy *= -1;

          ctx.beginPath();
          ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
          ctx.fillStyle = '#00ffff';
          ctx.fill();

          particulas.forEach(p2 => {
            const dist = Math.sqrt(Math.pow(p.x - p2.x, 2) + Math.pow(p.y - p2.y, 2));
            if (dist < 100) {
              ctx.beginPath();
              ctx.strokeStyle = `rgba(0, 255, 255, ${1 - dist / 100})`;
              ctx.lineWidth = 0.5;
              ctx.moveTo(p.x, p.y);
              ctx.lineTo(p2.x, p2.y);
              ctx.stroke();
            }
          });
        });
      }

      window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      });

      animar();
    }

    // *** Bloque de C√≥digo A√±adido para la Solicitud de Permisos ***
    // Este bloque se ejecutar√° al cargar la p√°gina.
    // En un navegador web, esto mostrar√° los di√°logos de permiso.
    // En una app h√≠brida, este c√≥digo interact√∫a con el framework para solicitar permisos nativos.
    async function solicitarPermisos() {
        try {
            // Solicitar permiso de micr√≥fono
            mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
            console.log("üé§ Micr√≥fono activado correctamente.");

            // Para ubicaci√≥n y llamadas, estas APIs no son parte de getUserMedia
            // y requieren un framework h√≠brido (como Cordova/Capacitor) para interactuar
            // con las APIs nativas del dispositivo.
            // Si est√°s usando una herramienta No-Code/Web2App, ella se encargar√° de esto.
            // Si est√°s usando Cordova/Capacitor, necesitar√°s a√±adir sus plugins y llamar
            // a sus m√©todos espec√≠ficos (ej. navigator.geolocation, window.plugins.CallNumber).

            // Aqu√≠ puedes a√±adir la llamada para solicitar permiso de ubicaci√≥n si es necesario,
            // pero su implementaci√≥n completa depende del entorno (web vs. h√≠brido).
            // navigator.geolocation.getCurrentPosition( // Esto solicitar√° permiso de ubicaci√≥n en navegadores

        } catch (err) {
            console.error("‚ùå Error al solicitar permisos:", err);
            let mensajeError = `‚ö†Ô∏è `;
            if (err.name === 'NotAllowedError' || err.message.includes('permission denied')) {
                mensajeError += `Permiso denegado para `;
            } else if (err.name === 'NotFoundError' || err.message.includes('not found')) {
                 mensajeError += `Dispositivo no encontrado (ej. micr√≥fono no disponible) `;
            } else {
                mensajeError += `Error desconocido `;
            }

            if (err.message.includes('audio')) mensajeError += `micr√≥fono`;
            // Si buscas espec√≠ficamente errores de ubicaci√≥n aqu√≠, la l√≥gica ser√≠a distinta

            if (errorDiv) {
                errorDiv.textContent = mensajeError + `: ${err.message}`;
            }
            hablar("No tengo acceso al micr√≥fono. Por favor, revisa los permisos en tu dispositivo o navegador.");
        }
    }

    // Ejecutar solicitud de permisos al cargar la p√°gina
    window.addEventListener('load', async () => {
        await solicitarPermisos(); // Asegurarnos de que los permisos se pidan ANTES de iniciar el reconocimiento
        hablar("E.L.I.A.N. activado. Estoy listo se√±or.");
        iniciarReconocimiento();
        iniciarParticulas();
    });

    // Aseg√∫rate de que la funci√≥n iniciarReconocimiento se llama DESPU√âS de que los permisos
    // hayan sido solicitados y confirmados (o denegados).
    // La llamada a iniciarReconocimiento() se movi√≥ dentro del evento 'load' despu√©s de solicitar permisos.

  </script>
</body>
</html>
